{"version":3,"sources":["../../lib/natural/util/stopwords.js","../util.js","../common.js","../rand.js","baseFile.js","../../lib/natural/trie/trie.js","indexFile.js","dataFile.js","index.js"],"names":["words","exports","stopwords","require","stopwordsStr","makeStopwordString","join","nextTick","fn","args","apply","zeroPad","str","String","slice","length","normalize","word","toLowerCase","replace","isStopword","indexOf","tokenizer","split","uniq","arr","filter","v","i","diff","subArr","x","includes","flat","concat","sample","array","count","indices","result","Array","j","Math","floor","random","val","undefined","isString","s","reject","predicate","item","prepText","text","isArray","deduped","options","bind","reduce","Function","call","prototype","isEnumerable","Object","propertyIsEnumerable","keys","Reflect","ownKeys","values","O","k","module","error","err","callback","Promise","RangeError","lookup","pos","profile","start","Date","files","getFilesFor","index","then","data","synsetOffset","done","catch","results","Error","push","indexLookup","self","resolve","find","record","indexRecord","status","ptrs","offsets","n","parseInt","tokens","lemma","ptrSymbol","senseCnt","tagsenseCnt","lookupPOS","all","map","exec","method","get","isFn","_noprofile","parse","shift","getPOS","nouns","verbs","adjectives","adverbs","rest","matches","is","lineDataToJSON","line","location","wCnt","synonyms","ptrOffset","pointerSymbol","sourceTarget","glossArray","definition","examples","lexFilenum","lexName","LEX_NAMES","lexId","gloss","def","exp","seek","offset","offsetTmp","Number","isNaN","randX","opts","startsWith","rand","assign","parts","doParts","tryPart","part","pop","weight","POS_factor","Total","ceil","partCallback","Noun","Verb","Adjective","Adverb","isTest","window","__mocha","BaseFile","type","dictPath","posName","filePath","loadError","loaded","debug","console","time","promise","ES6_IMPORT","timeEnd","file","default","load","res","Trie","caseSensitive","dictionary","$","cs","addString","string","wasWord","next","substring","addStrings","list","keysWithPrefix","prefix","recurse","node","stringAgg","resultsAgg","isEmpty","object","key","hasOwnProperty","c","contains","firstLetter","findMatchesOnPath","search","findPrefix","lastWord","getSize","total","unshift","doSample","label","getKeys","trie","IndexFile","ready","arguments","readLine","valid","single","DataFile","POS","a","r","WordPOS","config","defaults","initFiles","loader","Comp","reducer","coll","indexFiles","dataFiles","preload","preloadFiles","_preload","includeData","p"],"mappings":"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","file":"wordpos.min.js","sourceRoot":"..\\src\\browser","sourcesContent":["/*\nCopyright (c) 2011, Chris Umbel\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// a list of commonly used words that have little meaning and can be excluded\n// from analysis.\nvar words = [\n    'about', 'after', 'all', 'also', 'am', 'an', 'and', 'another', 'any', 'are', 'as', 'at', 'be',\n    'because', 'been', 'before', 'being', 'between', 'both', 'but', 'by', 'came', 'can',\n    'come', 'could', 'did', 'do', 'each', 'for', 'from', 'get', 'got', 'has', 'had',\n    'he', 'have', 'her', 'here', 'him', 'himself', 'his', 'how', 'if', 'in', 'into',\n    'is', 'it', 'like', 'make', 'many', 'me', 'might', 'more', 'most', 'much', 'must',\n    'my', 'never', 'now', 'of', 'on', 'only', 'or', 'other', 'our', 'out', 'over',\n    'said', 'same', 'see', 'should', 'since', 'some', 'still', 'such', 'take', 'than',\n    'that', 'the', 'their', 'them', 'then', 'there', 'these', 'they', 'this', 'those',\n    'through', 'to', 'too', 'under', 'up', 'very', 'was', 'way', 'we', 'well', 'were',\n    'what', 'where', 'which', 'while', 'who', 'with', 'would', 'you', 'your',\n    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n    'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '$', '1',\n    '2', '3', '4', '5', '6', '7', '8', '9', '0', '_'];\n    \n// tell the world about the noise words.    \nexports.words = words;\n","/**\r\n* util.js\r\n*\r\n* Copyright (c) 2012-2019 mooster@42at.com\r\n* https://github.com/moos/wordpos\r\n*\r\n* Released under MIT license\r\n*/\r\n\r\nlet stopwords = require('../lib/natural/util/stopwords').words;\r\nlet stopwordsStr = makeStopwordString(stopwords);\r\n\r\nfunction makeStopwordString(stopwords) {\r\n  return ' ' + stopwords.join(' ') + ' ';\r\n}\r\n\r\n// setImmediate executes callback AFTER promise handlers.\r\n// Without it, exceptions in callback may be caught by Promise.\r\nfunction nextTick(fn, args) {\r\n  if (fn) {\r\n    fn.apply(null, args);\r\n  }\r\n}\r\n\r\n// offsets must be zero-padded to 8 chars\r\nfunction zeroPad(str) {\r\n  var pad = '00000000'; // 8 zeros\r\n  return String(pad + str).slice(-pad.length);\r\n}\r\n\r\nfunction normalize(word) {\r\n  return word.toLowerCase().replace(/\\s+/g, '_');\r\n}\r\n\r\nfunction isStopword(stopwordsStr, word) {\r\n  return stopwordsStr.indexOf(' '+word+' ') >= 0;\r\n}\r\n\r\nfunction tokenizer(str) {\r\n  return str.split(/\\W+/);\r\n}\r\n\r\nfunction uniq(arr) {\r\n  return arr.filter((v, i) => arr.indexOf(v) === i);\r\n}\r\n\r\nfunction diff(arr, subArr) {\r\n  return arr.filter(x => !subArr.includes(x));\r\n}\r\n\r\n// flatten an array - 1-deep only!\r\nfunction flat(arr) {\r\n  return [].concat.apply([], arr);\r\n}\r\n\r\n// get random sample from array (note: count << array.length)\r\n// https://stackoverflow.com/a/37834217\r\nfunction sample(array, count) {\r\n  var indices = [];\r\n  var result = new Array(count);\r\n  for (let i = 0; i < count; i++ ) {\r\n      let j = Math.floor(Math.random() * (array.length - i) + i);\r\n      let val = array[indices[j] === undefined ? j : indices[j]];\r\n      if (val === undefined) {\r\n        result.length = i;\r\n        break;\r\n      }\r\n      result[i] = val;\r\n      indices[j] = indices[i] === undefined ? i : indices[i];\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction isString(s) {\r\n  return typeof s === 'string';\r\n}\r\n\r\nfunction reject(arr, predicate) {\r\n  return arr.filter(item => !predicate(item))\r\n}\r\n\r\nfunction prepText(text) {\r\n  if (Array.isArray(text)) return text;\r\n  var deduped = uniq(tokenizer(text));\r\n  if (!this.options.stopwords) return deduped;\r\n  return reject(deduped, isStopword.bind(null,\r\n    isString(this.options.stopwords) ? this.options.stopwords : stopwordsStr\r\n  ));\r\n}\r\n\r\n// node <= 6 polyfill\r\n// @see https://github.com/tc39/proposal-object-values-entries/blob/master/polyfill.js\r\nconst reduce = Function.bind.call(Function.call, Array.prototype.reduce);\r\nconst isEnumerable = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable);\r\nconst concat = Function.bind.call(Function.call, Array.prototype.concat);\r\nconst keys = Reflect.ownKeys;\r\nif (!Object.values) {\r\n  Object.values = function values(O) {\r\n    return reduce(keys(O), (v, k) => concat(v, typeof k === 'string' && isEnumerable(O, k) ? [O[k]] : []), []);\r\n  };\r\n}\r\n\r\n\r\nmodule.exports = {\r\n  isString,\r\n  zeroPad,\r\n  stopwords,\r\n  nextTick,\r\n  normalize,\r\n  tokenizer,\r\n  prepText,\r\n  makeStopwordString,\r\n  uniq,\r\n  diff,\r\n  flat,\r\n  sample\r\n};\r\n","/**\r\n* common.js\r\n*\r\n* Copyright (c) 2012-2019 mooster@42at.com\r\n* https://github.com/moos/wordpos\r\n*\r\n* Portions: Copyright (c) 2011, Chris Umbel\r\n*\r\n* Released under MIT license\r\n*/\r\n\r\nvar { normalize, nextTick, isString, uniq, sample, diff, flat } = require('./util');\r\n\r\nfunction error(err, callback) {\r\n  if (isString(err)) err = new RangeError(err);\r\n  callback && callback(err, {});\r\n  return Promise.reject(err);\r\n}\r\n\r\n/**\r\n * factory for main lookup function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function} - lookup function bound to POS\r\n * @this WordPOS\r\n */\r\nfunction lookup(pos) {\r\n  return function(word, callback) {\r\n    var profile = this.options.profile,\r\n      start = profile && new Date(),\r\n      files = this.getFilesFor(pos),\r\n      args = [];\r\n\r\n    word = normalize(word);\r\n\r\n    // lookup index\r\n    return files.index.lookup(word)\r\n      .then(function(result) {\r\n        if (result) {\r\n          // lookup data\r\n          return files.data.lookup(result.synsetOffset).then(done);\r\n        } else {\r\n          // not found in index\r\n          return done([]);\r\n        }\r\n      })\r\n      .catch(done);\r\n\r\n    function done(results) {\r\n      if (results instanceof Error) {\r\n        args.push([], word);\r\n      } else {\r\n        args.push(results, word);\r\n      }\r\n      //console.log(3333, args)\r\n      profile && args.push(new Date() - start);\r\n      nextTick(callback, args);\r\n      return results;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * find a word and prepare its lexical record\r\n *\r\n * @param word {string} - search word\r\n * @param callback {function} - callback function receives result\r\n * @returns {Promise.<IndexRecord>}\r\n * @this IndexFile\r\n *\r\n * Credit for this routine to https://github.com/NaturalNode/natural\r\n */\r\nfunction indexLookup(word, callback) {\r\n  var self = this;\r\n  return new Promise(function(resolve, reject){\r\n    self.find(word, function (record) {\r\n      var indexRecord = null,\r\n        i;\r\n\r\n      if (record.status == 'hit') {\r\n        var ptrs = [], offsets = [];\r\n        let n = parseInt(record.tokens[3]);\r\n\r\n        for (i = 0; i < n; i++) {\r\n          ptrs.push(record.tokens[i]);\r\n        }\r\n\r\n        n = parseInt(record.tokens[2]);\r\n        for (i = 0; i < n; i++) {\r\n          offsets.push(record.tokens[ptrs.length + 6 + i]);\r\n        }\r\n\r\n        indexRecord = {\r\n          lemma       : record.tokens[0],\r\n          pos         : record.tokens[1],\r\n          ptrSymbol   : ptrs,\r\n          senseCnt    : parseInt(record.tokens[ptrs.length + 4], 10),\r\n          tagsenseCnt : parseInt(record.tokens[ptrs.length + 5], 10),\r\n          synsetOffset: offsets\r\n        };\r\n      }\r\n      callback && callback(indexRecord);\r\n      resolve(indexRecord);\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * lookup a word in all indexes\r\n *\r\n * @param word {string} - search word\r\n * @param callback {Function} (optional) - callback with (results, word) signature\r\n * @returns {Promise}\r\n * @this WordPOS\r\n */\r\nfunction lookupPOS(word, callback) {\r\n  var self = this,\r\n    results = [],\r\n    profile = this.options.profile,\r\n    start = profile && new Date(),\r\n    methods = ['lookupAdverb', 'lookupAdjective', 'lookupVerb', 'lookupNoun'];\r\n\r\n  return Promise\r\n    .all(methods.map(exec))\r\n    .then(done)\r\n    .catch(error);\r\n\r\n  function exec(method) {\r\n    return self[ method ]\r\n      .call(self, word)\r\n      .then(function collect(result){\r\n        results = results.concat(result);\r\n      });\r\n  }\r\n\r\n  function done() {\r\n    var args = [results, word];\r\n    profile && args.push(new Date() - start);\r\n    nextTick(callback, args);\r\n    return results;\r\n  }\r\n\r\n  function error(err) {\r\n    nextTick(callback, [[], word]);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * getX() factory function\r\n *\r\n * @param isFn {function} - an isX() function\r\n * @returns {Function}\r\n * @this IndexFile\r\n */\r\nfunction get(isFn) {\r\n  return function(text, callback, _noprofile) {\r\n    var profile = this.options.profile && !_noprofile,\r\n      start = profile && new Date(),\r\n      words = this.parse(text),\r\n      results = [],\r\n      self = this,\r\n      first = words.shift();\r\n\r\n    // test one first & check for error, otherwise\r\n    // map is inoccuous to errors!\r\n    return exec(first)\r\n      .then(() => Promise.all(words.map(exec)))\r\n      .then(done)\r\n      .catch(err => {\r\n        // done(); // callback signature is same!  // FIXME\r\n        return Promise.reject(err);\r\n      });\r\n\r\n    function exec(word) {\r\n      return self[isFn]\r\n        .call(self, word, null, /*_noprofile*/ true)\r\n        .then(function collect(result) {\r\n          result && results.push(word);\r\n        });\r\n    }\r\n\r\n    function done(){\r\n      var args = [results];\r\n      profile && args.push(new Date() - start);\r\n      nextTick(callback, args);\r\n      return results;\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * getPOS() - Find all POS for all words in given string\r\n *\r\n * @param text {string} - words to lookup for POS\r\n * @param callback {function} (optional) - receives object with words broken into POS or 'rest', ie,\r\n * \t    Object: {nouns:[], verbs:[], adjectives:[], adverbs:[], rest:[]}\r\n * @return Promise - resolve function receives data object\r\n */\r\nfunction getPOS(text, callback) {\r\n  var self = this,\r\n    data = {nouns:[], verbs:[], adjectives:[], adverbs:[], rest:[]},\r\n    profile = this.options.profile,\r\n    start = profile && new Date(),\r\n    words = this.parse(text),\r\n    methods = ['getAdverbs', 'getAdjectives', 'getVerbs', 'getNouns'];\r\n\r\n  return Promise\r\n    .all(methods.map(exec))\r\n    .then(done)\r\n    .catch(error);\r\n\r\n  function exec(method) {\r\n    return self[ method ]\r\n      .call(self, text, null, true)\r\n      .then(function collect(results) {\r\n        // getAdjectives --> adjectives\r\n        var pos = method.replace('get','').toLowerCase();\r\n        data[ pos ] =  results;\r\n      });\r\n  }\r\n\r\n  function done() {\r\n    var args = [data];\r\n    var matches = uniq(flat(Object.values(data)));\r\n    data.rest = diff(words, matches);\r\n\r\n    profile && args.push(new Date() - start);\r\n    nextTick(callback, args);\r\n    return data;\r\n  }\r\n\r\n  function error(err) {\r\n    nextTick(callback, []);\r\n    throw err;\r\n  }\r\n}\r\n\r\n/**\r\n * isX() factory function\r\n *\r\n * @param pos {string} - n/v/a/r\r\n * @returns {Function}\r\n * @this WordPOS\r\n */\r\nfunction is(pos){\r\n  return function(word, callback, _noprofile) {\r\n    // disable profiling when isX() used internally\r\n    var profile = this.options.profile && !_noprofile,\r\n      start = profile && new Date(),\r\n      args = [],\r\n      index = this.getFilesFor(pos).index;\r\n    word = normalize(word);\r\n\r\n    return index\r\n      .lookup(word)\r\n      .then(function(record) {\r\n        var result = !!record;\r\n        args.push(result, word);\r\n        profile && args.push(new Date() - start);\r\n        nextTick(callback, args);\r\n        return result;\r\n      });\r\n  };\r\n}\r\n\r\n/**\r\n * parse a single data file line, returning data object\r\n *\r\n * @param line {string} - a single line from WordNet data file\r\n * @returns {object}\r\n *\r\n * Credit for this routine to https://github.com/NaturalNode/natural\r\n */\r\nfunction lineDataToJSON(line, location) {\r\n  var data = line.split('| '),\r\n    tokens = data[0].split(/\\s+/),\r\n    ptrs = [],\r\n    wCnt = parseInt(tokens[3], 16),\r\n    synonyms = [],\r\n    i;\r\n\r\n  for(i = 0; i < wCnt; i++) {\r\n    synonyms.push(tokens[4 + i * 2]);\r\n  }\r\n\r\n  var ptrOffset = (wCnt - 1) * 2 + 6;\r\n  let n = parseInt(tokens[ptrOffset], 10);\r\n  for(i = 0; i < n; i++) {\r\n    ptrs.push({\r\n      pointerSymbol: tokens[ptrOffset + 1 + i * 4],\r\n      synsetOffset: tokens[ptrOffset + 2 + i * 4],\r\n      pos: tokens[ptrOffset + 3 + i * 4],\r\n      sourceTarget: tokens[ptrOffset + 4 + i * 4]\r\n    });\r\n  }\r\n\r\n  // break \"gloss\" into definition vs. examples\r\n  var glossArray = data[1].split('; ');\r\n  var definition = glossArray[0];\r\n  var examples = glossArray.slice(1);\r\n  var lexFilenum = parseInt(tokens[1], 10);\r\n\r\n  for (var k = 0; k < examples.length; k++) {\r\n    examples[k] = examples[k].replace(/\\\"/g,'').replace(/\\s\\s+/g,'');\r\n  }\r\n\r\n  return {\r\n    synsetOffset: tokens[0],\r\n    lexFilenum: lexFilenum,\r\n    lexName: LEX_NAMES[ lexFilenum ],\r\n    pos: tokens[2],\r\n    wCnt: wCnt,\r\n    lemma: tokens[4],\r\n    synonyms: synonyms,\r\n    lexId: tokens[5],\r\n    ptrs: ptrs,\r\n    gloss: data[1],\r\n    def: definition,\r\n    exp: examples\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * seek - get record at offset for pos\r\n *\r\n * @param offset {number} - synset offset\r\n * @param pos {string} - POS a/r/n/v\r\n * @param callback {function} - optional callback\r\n * @returns Promise\r\n * @this WordPOS\r\n */\r\nfunction seek(offset, pos, callback){\r\n  var offsetTmp = Number(offset);\r\n  if (isNaN(offsetTmp) || offsetTmp <= 0) return error('Offset must be valid positive number: ' + offset, callback);\r\n\r\n  var data = this.getFilesFor(pos).data;\r\n  if (!data) return error('Incorrect POS - 2nd argument must be a, r, n or v.', callback);\r\n\r\n  return data.lookup(offset, callback);\r\n}\r\n\r\nconst LEX_NAMES = [\r\n 'adj.all',\r\n 'adj.pert',\r\n 'adv.all',\r\n 'noun.Tops',\r\n 'noun.act',\r\n 'noun.animal',\r\n 'noun.artifact',\r\n 'noun.attribute',\r\n 'noun.body',\r\n 'noun.cognition',\r\n 'noun.communication',\r\n 'noun.event',\r\n 'noun.feeling',\r\n 'noun.food',\r\n 'noun.group',\r\n 'noun.location',\r\n 'noun.motive',\r\n 'noun.object',\r\n 'noun.person',\r\n 'noun.phenomenon',\r\n 'noun.plant',\r\n 'noun.possession',\r\n 'noun.process',\r\n 'noun.quantity',\r\n 'noun.relation',\r\n 'noun.shape',\r\n 'noun.state',\r\n 'noun.substance',\r\n 'noun.time',\r\n 'verb.body',\r\n 'verb.change',\r\n 'verb.cognition',\r\n 'verb.communication',\r\n 'verb.competition',\r\n 'verb.consumption',\r\n 'verb.contact',\r\n 'verb.creation',\r\n 'verb.emotion',\r\n 'verb.motion',\r\n 'verb.perception',\r\n 'verb.possession',\r\n 'verb.social',\r\n 'verb.stative',\r\n 'verb.weather',\r\n 'adj.ppl'\r\n];\r\n\r\nmodule.exports= {\r\n  indexLookup,\r\n  is,\r\n  get,\r\n  seek,\r\n  getPOS,\r\n\r\n  lineDataToJSON,\r\n  LEX_NAMES,\r\n  lookup,\r\n  lookupPOS\r\n}\r\n","/**\r\n* rand.js\r\n*\r\n* Copyright (c) 2012-2019 mooster@42at.com\r\n* https://github.com/moos/wordpos\r\n*\r\n* Released under MIT license\r\n*/\r\n\r\nvar { uniq, sample } = require('./util');\r\n\r\n/**\r\n * factory function for randX()\r\n *\r\n * @param pos {string} - a,r,n,v\r\n * @returns {Function} - rand function bound to an index file\r\n * @this WordPOS\r\n */\r\nfunction randX(pos){\r\n  return function(opts, callback, _noprofile) {\r\n    // disable profiling when isX() used internally\r\n    var profile = this.options.profile && !_noprofile,\r\n      start = profile && new Date(),\r\n      args = [],\r\n      index = this.getFilesFor(pos).index,\r\n      startsWith = opts && opts.startsWith || '',\r\n      count = opts && opts.count || 1;\r\n\r\n    if (typeof opts === 'function') {\r\n      callback = opts;\r\n    }\r\n\r\n    return index.rand(startsWith, count, function (record) {\r\n      args.push(record, startsWith);\r\n      profile && args.push(new Date() - start);\r\n      callback && callback.apply(null, args);\r\n    });\r\n  };\r\n}\r\n\r\n\r\n/**\r\n * rand() - for all Index files\r\n *\r\n * @param [opts] {object} options\r\n * @param opts.startsWith {string} string random words should start with\r\n * @param opts.count {integer} number of random words to return\r\n * @param callback {function} - callback receives (results, startsWith, profile)\r\n * @returns {Promise} receives results\r\n * @this WordPOS\r\n */\r\nfunction rand(opts, callback) {\r\n  if (typeof opts === 'function') {\r\n    callback = opts;\r\n    opts = {};\r\n  } else {\r\n    opts = Object.assign({\r\n      startsWith: '',\r\n      count: 1\r\n    }, opts);\r\n  }\r\n\r\n  var\r\n    profile = this.options.profile,\r\n    start = profile && new Date(),\r\n    results = [],\r\n    count = opts.count,\r\n    args = [null, opts.startsWith],\r\n    parts = 'Noun Verb Adjective Adverb'.split(' '),\r\n    self = this;\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    // select at random a POS to look at\r\n    var doParts = sample(parts, parts.length);\r\n    tryPart();\r\n\r\n    function tryPart() {\r\n      var part = doParts.pop(),\r\n        rand = 'rand' + part,\r\n        factor = POS_factor[part],\r\n        weight = factor / POS_factor.Total;\r\n\r\n      // pick count according to relative weight\r\n      opts.count = Math.ceil(count * weight * 1.1); // guard against dupes\r\n      self[rand](opts, partCallback);\r\n    }\r\n\r\n    function partCallback(result) {\r\n      if (result) {\r\n        results = uniq(results.concat(result));  // make sure it's unique!\r\n      }\r\n\r\n      if (results.length < count && doParts.length) {\r\n        return tryPart();\r\n      }\r\n\r\n      // final random and trim excess\r\n      results = sample(results, count);\r\n      done();\r\n    }\r\n\r\n    function done() {\r\n      profile && (args.push(new Date() - start));\r\n      args[0] = results;\r\n      callback && callback.apply(null, args);\r\n      resolve(results);\r\n    }\r\n\r\n  }); // Promise\r\n}\r\n\r\n\r\n// relative weight of each POS word count (DB 3.1 numbers)\r\nconst POS_factor = {\r\n  Noun: 26,\r\n  Verb: 3,\r\n  Adjective: 5,\r\n  Adverb: 1,\r\n  Total: 37\r\n};\r\n\r\nmodule.exports = {\r\n  randX,\r\n  rand\r\n};\r\n","/**\r\n * browser/baseFile.js\r\n *\r\n * Copyright (c) 2012-2019 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Released under MIT license\r\n */\r\n\r\nlet isTest = window.__mocha;\r\n\r\nclass BaseFile {\r\n\r\n  /**\r\n   * file contents - in browser it's just a string & not a file!\r\n   * @type {Object}\r\n   */\r\n  file = {};\r\n\r\n  /**\r\n   * constructor\r\n   * @param {type} type - 'index' or 'data'\r\n   * @param {string} dictPath - path to dict db\r\n   * @param {string} posName - one of 'noun', 'verb', 'adj', 'adv'\r\n   * @param {object} [options] - @see WordPOS options\r\n   */\r\n\r\n  constructor(type, dictPath, posName, options) {\r\n    this.type = type;\r\n    this.filePath = `${dictPath}/${type}.${posName}.js`;\r\n    this.posName = posName;\r\n    this.loadError = null;\r\n    this.options = Object.assign({}, options);\r\n  }\r\n\r\n  load() {\r\n    if (this.loadError) return Promise.reject(this.loadError);\r\n    if (this.loaded) return this.loaded;\r\n\r\n    this.options.debug && console.time('index load ' + this.posName);\r\n\r\n    let promise = isTest\r\n      ? Promise.resolve(require(this.filePath))\r\n      : ES6_IMPORT(`${this.filePath}`); // prevent parcel from clobbering dynamic import\r\n\r\n    this.options.debug && console.timeEnd('index load ' + this.posName)\r\n    return this.loaded = promise\r\n      .then(exports => {\r\n        this.file = exports.default;\r\n        return this;\r\n      })\r\n      .catch(err => {\r\n        console.error(`Error loading \"${this.type}\" file ${this.filePath}.`, err);\r\n        this.loadError = err;\r\n        throw err;\r\n      });\r\n  }\r\n\r\n  ready(fn, args) {\r\n    return this.load().then(res => fn && fn.apply(this, args) || res);\r\n  }\r\n}\r\n\r\n// export default BaseFile;\r\nmodule.exports = BaseFile;\r\n","/*\nCopyright (c) 2014 Ken Koch\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n/** \n * The basis of the TRIE structure.\n **/\nfunction Trie(caseSensitive) {\n\tthis.dictionary = {};\n\tthis.$ = false;\n\n\tif(typeof caseSensitive === \"undefined\") {\n\t\tcaseSensitive = true;\n\t}\n\n\tthis.cs = caseSensitive;\n}\n\n/**\n * Add a single string to the TRIE, returns true if the word was already in the \n * trie.\n **/\nTrie.prototype.addString = function(string) {\n\tif(this.cs === false) {\n\t\tstring = string.toLowerCase();\n\t}\n\n\t// If the string has only one letter, mark this as a word.\n\tif(string.length === 0) {\n\t\tvar wasWord = this.$;\n\t\tthis.$ = true;\n\t\treturn wasWord;\n\t}\n\n\t// Make sure theres a Trie node in our dictionary\n\tvar next = this.dictionary[string[0]];\n\n\tif(!next) {\n\t\tthis.dictionary[string[0]] = new Trie(this.cs);\n\t\tnext = this.dictionary[string[0]];\n\t}\n\n\t// Continue adding the string\n\treturn next.addString(string.substring(1));\n};\n\n/**\n * Add multiple strings to the TRIE\n **/\nTrie.prototype.addStrings = function(list) {\n\tfor(var i in list) {\n\t\tthis.addString(list[i]);\n\t}\n};\n\n/**\n * A function to search the TRIE and return an array of\n * words which have same prefix <prefix>\n * for example if we had the following words in our database:\n * a, ab, bc, cd, abc, abd\n * and we search the string: a\n * we will get :\n * [a, ab, abc, abd]\n **/\nTrie.prototype.keysWithPrefix = function(prefix) {\n    if(this.caseSensitive === false) {\n        prefix = prefix.toLowerCase();\n    }\n\n    function isEmpty (object) {\n        for (var key in object) if (object.hasOwnProperty(key)) return false;\n        return true;\n    }\n\n    function get (node, word) {\n        if(!node) return null;\n        if(word.length == 0) return node;\n        return get(node.dictionary[word[0]], word.substring(1));\n    }\n\n    function recurse ( node, stringAgg, resultsAgg) {\n        if (!node) return;\n\n        // Check if this is a word\n        if (node.$) {\n            resultsAgg.push(stringAgg);\n        }\n\n        if (isEmpty(node.dictionary)) {\n            return ;\n        }\n\n        for (var c in node.dictionary) {\n            recurse (node.dictionary[c],stringAgg + c, resultsAgg);\n        }\n    }\n\n    var results = [];\n    recurse (get(this, prefix), prefix, results);\n    return results;\n};\n\n/** \n * A function to search the given string and return true if it lands\n * on on a word. Essentially testing if the word exists in the database.\n **/\nTrie.prototype.contains = function(string) {\n\tif(this.cs === false) {\n\t\tstring = string.toLowerCase();\n\t}\n\n\tif(string.length === 0) {\n\t\treturn this.$;\n\t}\n\n\t// Otherwise, we need to continue searching\n\tvar firstLetter = string[0];\n\tvar next = this.dictionary[firstLetter];\t\t\n\n\t// If we don't have a node, this isn't a word\n\tif(!next) {\n\t\treturn false;\n\t}\n\n\t// Otherwise continue the search at the next node\n\treturn next.contains(string.substring(1));\n}\n\n/**\n * A function to search the TRIE and return an array of words which were encountered along the way.\n * This will only return words with full prefix matches.\n * for example if we had the following words in our database:\n * a, ab, bc, cd, abc\n * and we searched the string: abcd\n * we would get only:\n * [a, ab, abc]\n **/\nTrie.prototype.findMatchesOnPath = function(search) {\n\tif(this.cs === false) {\n\t\tsearch = search.toLowerCase();\n\t}\n\n\tfunction recurse(node, search, stringAgg, resultsAgg) {\n\t\t// Check if this is a word.\n\t\tif(node.$) {\n\t\t\tresultsAgg.push(stringAgg);\n\t\t}\n\n\t\t// Check if the have completed the seearch\n\t\tif(search.length === 0) {\n\t\t\treturn resultsAgg;\n\t\t}\n\n\t\t// Otherwise, continue searching\n\t\tvar next = node.dictionary[search[0]];\n\t\tif(!next) {\n\t\t\treturn resultsAgg;\n\t\t}\n\t\treturn recurse(next, search.substring(1), stringAgg + search[0], resultsAgg);\n\t};\n\n\treturn recurse(this, search, \"\", []);\n};\n\n/**\n * Returns the longest match and the remaining part that could not be matched.\n * inspired by [NLTK containers.trie.find_prefix](http://nltk.googlecode.com/svn-/trunk/doc/api/nltk.containers.Trie-class.html).\n **/\nTrie.prototype.findPrefix = function(search) {\n\tif(this.cs === false) {\n\t\tsearch = search.toLowerCase();\n\t}\n\t\n\tfunction recurse(node, search, stringAgg, lastWord) {\n\t\t// Check if this is a word\n\t\tif(node.$) {\n\t\t\tlastWord = stringAgg;\n\t\t}\n\n\t\t// Check if we have no more to search\n\t\tif(search.length === 0) {\n\t\t\treturn [lastWord, search];\n\t\t}\n\n\t\t// Continue searching\n\t\tvar next = node.dictionary[search[0]];\n\t\tif(!next) {\n\t\t\treturn [lastWord, search];\n\t\t}\n\t\treturn recurse(next, search.substring(1), stringAgg + search[0], lastWord);\n\t};\n\n\treturn recurse(this, search, \"\", null);\n};\n\n/**\n * Computes the number of actual nodes from this node to the end.\n * Note: This involves traversing the entire structure and may not be\n * good for frequent use.\n **/\nTrie.prototype.getSize = function() { \n\tvar total = 1;\n\tfor(var c in this.dictionary) {\n\t\ttotal += this.dictionary[c].getSize();\n\t}\n\treturn total;\n};\n\n/**\n * EXPORT THE TRIE\n **/\nmodule.exports = Trie;\n\n","/**\r\n * browser/indexFile.js\r\n *\r\n * Copyright (c) 2012-2019 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Released under MIT license\r\n */\r\n\r\nconst { indexLookup } = require('../common');\r\nconst { sample } = require('../util');\r\nconst BaseFile = require('./baseFile');\r\nconst Trie = require('../../lib/natural/trie/trie');\r\n\r\n/**\r\n * find a search term in an index file (using fast index)\r\n *\r\n * Calls to same bucket are queued for callback using the piper.\r\n *\r\n * @param search {string} - word to search for\r\n * @param callback {function} - callback receives found line and tokens\r\n * @returns none\r\n * @this IndexFile\r\n */\r\nfunction find(search, callback) {\r\n  var miss = {status: 'miss'};\r\n\r\n  if (!(search in this.file)) {\r\n    callback(miss);\r\n    return;\r\n  }\r\n\r\n  var\r\n    line = this.file[search],\r\n    tokens = line.split(/\\s+/),\r\n    result = {\r\n      status: 'hit',\r\n      key: search,\r\n      line: line,\r\n      tokens: tokens\r\n    };\r\n\r\n  result.tokens.unshift(search);\r\n  callback(result);\r\n}\r\n\r\n/**\r\n * Select <count> words at random for POS\r\n *\r\n * @param  {string} startsWith - string that results should start with\r\n * @param  {integer} count - number of results to return\r\n * @param  {Function} callback - receives (results, startsWith)\r\n * @return {Promise} receives results\r\n * @this IndexFile\r\n */\r\nfunction rand(startsWith, count, callback) {\r\n  const done = (res) => {\r\n    callback(res, startsWith || '');\r\n    return Promise.resolve(res);\r\n  };\r\n\r\n  const doSample = (values) => {\r\n    let res = sample(values, count);\r\n    // console.timeEnd('getkeys')\r\n    return done(res);\r\n  };\r\n\r\n  const time = (label) => {\r\n    this.options.debug && console.time(label + ' ' + this.posName);\r\n  };\r\n\r\n  const timeEnd = (label) => {\r\n    this.options.debug && console.timeEnd(label + ' ' + this.posName);\r\n  };\r\n\r\n  if (!startsWith) {\r\n    // console.time('getkeys')\r\n    return doSample(this.getKeys());\r\n  }\r\n\r\n  // calc trie if haven't done so yet\r\n  if (!this.trie) {\r\n    time('Trie');\r\n    this.trie = new Trie();\r\n    this.trie.addStrings(this.getKeys());\r\n    timeEnd('Trie');\r\n  }\r\n\r\n  let keys = [];\r\n  time('trie-withprefix');\r\n  keys = this.trie.keysWithPrefix(startsWith);\r\n  timeEnd('trie-withprefix');\r\n\r\n  // TODO cache results?\r\n\r\n  return keys.length ? doSample(keys) : done([]);\r\n}\r\n\r\n/**\r\n * IndexFile class\r\n */\r\nclass IndexFile extends BaseFile {\r\n\r\n  keys = null;\r\n\r\n  /**\r\n   * @param dictPath {string} - WordNet db dict path\r\n   * @param posName {string} - name of index: noun, verb, adj, adv\r\n   * @param {object} [options] - @see WordPOS options\r\n   * @constructor\r\n   */\r\n  constructor(dictPath, posName, options) {\r\n    super('index', dictPath, posName, options);\r\n    this.options = Object.assign({}, options);\r\n    this.posName = posName;\r\n  }\r\n\r\n  getKeys() {\r\n    return this.keys || (this.keys = Object.keys(this.file));\r\n  }\r\n\r\n  lookup() {\r\n    return this.ready(indexLookup, arguments);\r\n  }\r\n\r\n  find() {\r\n    return this.ready(find, arguments);\r\n  }\r\n\r\n  rand() {\r\n    return this.ready(rand, arguments);\r\n  }\r\n}\r\n\r\nmodule.exports = IndexFile;\r\n","/**\r\n * browser/dataFile.js\r\n *\r\n * Copyright (c) 2012-2019 mooster@42at.com\r\n * https://github.com/moos/wordpos\r\n *\r\n * Portions: Copyright (c) 2011, Chris Umbel\r\n *\r\n * Released under MIT license\r\n */\r\n\r\nconst { lineDataToJSON, LEX_NAMES } = require('../common');\r\nconst { zeroPad } = require('../util');\r\nconst BaseFile = require('./baseFile');\r\n\r\n/**\r\n * get parsed line from data file\r\n *\r\n * @param  {string} offset The offset key\r\n * @return {object} Data record object\r\n * @this DataFile\r\n */\r\nfunction seek(offset) {\r\n  let str = this.file[offset];\r\n  if (!str) return {};\r\n  // offset was extracted for the key - add it back to line data\r\n  return lineDataToJSON(offset + ' ' + str);\r\n}\r\n\r\n/**\r\n * lookup offsets in data file\r\n *\r\n * @param offsets {array} - array of offsets to lookup (obtained from index.find())\r\n * @param callback{function} (optional) - callback function\r\n * @returns {Promise.[<Object>]} array of or single data record\r\n * @this DataFile\r\n */\r\nfunction lookup(offsets, callback) {\r\n  var results = [],\r\n    self = this,\r\n    readLine = seek.bind(this),\r\n    valid = (item => item.pos),\r\n    single = !Array.isArray(offsets);\r\n\r\n  if (single) offsets = [offsets];\r\n  return new Promise(function(resolve, reject) {\r\n    results = offsets\r\n      .map(zeroPad)\r\n      .map(readLine)\r\n      .filter(valid);\r\n\r\n    if (!results.length) {\r\n      let err = new RangeError(`No data at offsets ${offsets.join()} in ${self.filePath}.`);\r\n      callback && callback(err, single ? {} :[]);\r\n      reject(err);\r\n    } else {\r\n      if (single) results = results[0];\r\n      callback && callback(null, results);\r\n      resolve(results);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * DataFile class\r\n *\r\n * @param dictPath {string} - path to dict folder\r\n * @param posName {string} - POS name\r\n * @constructor\r\n */\r\nclass DataFile extends BaseFile {\r\n\r\n  constructor(dictPath, posName) {\r\n    super('data', dictPath, posName);\r\n  }\r\n\r\n  lookup() {\r\n    return this.ready(lookup, arguments);\r\n  }\r\n}\r\n\r\n/**\r\n * map of lexFilenum to lex names\r\n *\r\n * @see https://wordnet.princeton.edu/wordnet/man/lexnames.5WN.html\r\n * @type {string[]}\r\n */\r\nDataFile.LEX_NAMES = LEX_NAMES;\r\n\r\nmodule.exports = DataFile;\r\n","/**\r\n* browser/index.js\r\n*\r\n* Copyright (c) 2012-2019 mooster@42at.com\r\n* https://github.com/moos/wordpos\r\n*\r\n* Released under MIT license\r\n*/\r\n\r\nconst { stopwords, prepText, makeStopwordString, flat } = require('../util');\r\nconst { is, get, getPOS, lookup, seek, lookupPOS } = require('../common');\r\nconst { randX, rand } = require('../rand');\r\nconst IndexFile = require('./indexFile');\r\nconst DataFile = require('./dataFile');\r\n\r\nconst POS = {\r\n  n: 'noun',\r\n  v: 'verb',\r\n  a: 'adj',\r\n  r: 'adv'\r\n};\r\n\r\n\r\nclass WordPOS {\r\n\r\n  options = {};\r\n\r\n  constructor(config) {\r\n    this.options = Object.assign({}, WordPOS.defaults, config);\r\n\r\n    this.initFiles();\r\n    if (Array.isArray(this.options.stopwords)) {\r\n      this.options.stopwords = makeStopwordString(this.options.stopwords);\r\n    }\r\n  }\r\n\r\n  ready() {\r\n    return this.loaded || Promise.resolve();\r\n  }\r\n\r\n  initFiles() {\r\n    const keys = Object.keys(POS);\r\n    const loadOne = (Comp, pos) => new Comp(this.options.dictPath, POS[pos], this.options);\r\n    const loader = (Comp) => keys.map(loadOne.bind(null, Comp));\r\n    const reducer = (arr) => arr.reduce((coll, item, i) => (coll[keys[i]] = item, coll), {});\r\n\r\n    this.indexFiles = reducer(loader(IndexFile));\r\n    this.dataFiles = reducer(loader(DataFile));\r\n\r\n    if (this.options.preload) {\r\n      this.loaded = this.preloadFiles(this.options.preload);\r\n    }\r\n  }\r\n\r\n  getFilesFor(pos) {\r\n    return {\r\n      index: this.indexFiles[pos],\r\n      data: this.dataFiles[pos]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * loads index files\r\n   *\r\n   * @param  {string|Array} [pos] POS to load (default: all)\r\n   * @return {Promise.<index data>}\r\n   */\r\n  preloadFiles(pos) {\r\n    let promise = this._preload(this.indexFiles, pos);\r\n    if (this.options.includeData) {\r\n      promise = Promise.all([].concat(promise, this._preload(this.dataFiles, pos)))\r\n        .then(res => flat(res));\r\n    }\r\n    return promise;\r\n  }\r\n\r\n  _preload(files, pos) {\r\n    let load = p => files[p].load();\r\n    let promise;\r\n\r\n    if (!pos || pos === true) { // preload all\r\n      promise = Promise.all(Object.keys(POS).map(load));\r\n    }\r\n    else if (typeof pos === 'string' && files[pos]) {\r\n      promise = load(pos);\r\n    }\r\n    else if (pos instanceof Array) {\r\n      promise = Promise.all(pos.map(load));\r\n    }\r\n    return promise || Promise.reject(new RangeError(`Unknown POS \"${pos}\" for preload.`));\r\n  }\r\n\r\n  parse = prepText;\r\n\r\n  seek = seek;\r\n\r\n  /**\r\n   * isX() - Test if word is given POS\r\n   * @see is\r\n   */\r\n  isAdjective = is('a');\r\n  isAdverb = is('r');\r\n  isNoun = is('n');\r\n  isVerb = is('v');\r\n\r\n  /**\r\n   * getX() - Find all words in string that are given POS\r\n   * @see get\r\n   */\r\n  getPOS = getPOS;\r\n  getAdjectives = get('isAdjective');\r\n  getAdverbs = get('isAdverb');\r\n  getNouns = get('isNoun');\r\n  getVerbs = get('isVerb');\r\n\r\n  /**\r\n   * lookupX() - Lookup word definition if already know POS\r\n   * @see lookup\r\n   */\r\n  lookup = lookupPOS;\r\n  lookupAdjective = lookup('a');\r\n  lookupAdverb = lookup('r');\r\n  lookupNoun = lookup('n');\r\n  lookupVerb = lookup('v');\r\n\r\n  /**\r\n   * define randX()\r\n   * @see makeRandX\r\n   */\r\n  rand = rand;\r\n  randAdjective = randX('a');\r\n  randAdverb = randX('r');\r\n  randNoun = randX('n');\r\n  randVerb = randX('v');\r\n\r\n}\r\n\r\nWordPOS.defaults = {\r\n  /**\r\n   * path to WordNet data (override only if not using wordnet-db)\r\n   * @type {string}\r\n   */\r\n  dictPath: '',\r\n\r\n  /**\r\n   * enable profiling, time in msec returned as second argument in callback\r\n   * @type {boolean}\r\n   */\r\n  profile: false,\r\n\r\n  /**\r\n   * if true, exclude standard stopwords.\r\n   * if array, stopwords to exclude, eg, ['all','of','this',...]\r\n   * if false, do not filter any stopwords.\r\n   * @type {boolean}\r\n   */\r\n  stopwords: true,\r\n\r\n  /**\r\n   * preload files.\r\n   *    true - preload all POS\r\n   *    false - do not preload any POS\r\n   *    'a' - preload adj\r\n   *    ['a','v'] - preload adj & verb\r\n   * @type {boolean|string|Array}\r\n   */\r\n  preload: false,\r\n\r\n  /**\r\n   * include data files in preload\r\n   * @type {boolean}\r\n   */\r\n  includeData: false,\r\n\r\n  /**\r\n   * set to true to enable debug logging\r\n   * @type {boolean}\r\n   */\r\n  debug: false\r\n\r\n};\r\n\r\n/**\r\n * access to WordNet DB\r\n * @type {object}\r\n */\r\n// WordPOS.WNdb = WNdb;  // FIXME\r\n\r\n/**\r\n * access to stopwords\r\n * @type {Array}\r\n */\r\nWordPOS.stopwords = stopwords;\r\n\r\nWordPOS.POS = POS;\r\n\r\n// Export as CJS handled by Parcel, otherwise will get WordPOS.default\r\n// if use: export default WordPOS;\r\nmodule.exports = WordPOS;\r\n"]}